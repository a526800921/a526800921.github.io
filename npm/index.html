<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>项目文档</title>
    <meta name="description" content="项目文档">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.495fb3d6.css" as="style"><link rel="preload" href="/assets/js/app.cf21e5a9.js" as="script"><link rel="preload" href="/assets/js/2.1fbd1c76.js" as="script"><link rel="preload" href="/assets/js/10.06005cdb.js" as="script"><link rel="prefetch" href="/assets/js/11.4e950798.js"><link rel="prefetch" href="/assets/js/12.b406d258.js"><link rel="prefetch" href="/assets/js/3.5a23f80c.js"><link rel="prefetch" href="/assets/js/4.90160e26.js"><link rel="prefetch" href="/assets/js/5.75c2e8ec.js"><link rel="prefetch" href="/assets/js/6.ee5115cc.js"><link rel="prefetch" href="/assets/js/7.6583ed54.js"><link rel="prefetch" href="/assets/js/8.ed75f2d5.js"><link rel="prefetch" href="/assets/js/9.b885d552.js">
    <link rel="stylesheet" href="/assets/css/0.styles.495fb3d6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">项目文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/guide/" class="sidebar-link">指南</a></li><li><a href="/npm/" class="active sidebar-link">npm包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/npm/#stat" class="sidebar-link">stat</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/npm/#开始" class="sidebar-link">开始</a></li><li class="sidebar-sub-header"><a href="/npm/#版本迭代" class="sidebar-link">版本迭代</a></li><li class="sidebar-sub-header"><a href="/npm/#需求场景" class="sidebar-link">需求场景</a></li><li class="sidebar-sub-header"><a href="/npm/#初步设想" class="sidebar-link">初步设想</a></li><li class="sidebar-sub-header"><a href="/npm/#代码实现" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/npm/#结语" class="sidebar-link">结语</a></li></ul></li><li class="sidebar-sub-header"><a href="/npm/#watch-route" class="sidebar-link">watch-route</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/npm/#开始-2" class="sidebar-link">开始</a></li><li class="sidebar-sub-header"><a href="/npm/#版本迭代-2" class="sidebar-link">版本迭代</a></li><li class="sidebar-sub-header"><a href="/npm/#需求场景-2" class="sidebar-link">需求场景</a></li><li class="sidebar-sub-header"><a href="/npm/#初步设想-2" class="sidebar-link">初步设想</a></li><li class="sidebar-sub-header"><a href="/npm/#代码实现-2" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/npm/#结语-2" class="sidebar-link">结语</a></li></ul></li><li class="sidebar-sub-header"><a href="/npm/#host-sdk" class="sidebar-link">host-sdk</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/npm/#开始-3" class="sidebar-link">开始</a></li><li class="sidebar-sub-header"><a href="/npm/#版本迭代-3" class="sidebar-link">版本迭代</a></li><li class="sidebar-sub-header"><a href="/npm/#需求场景-3" class="sidebar-link">需求场景</a></li><li class="sidebar-sub-header"><a href="/npm/#初步设想-3" class="sidebar-link">初步设想</a></li><li class="sidebar-sub-header"><a href="/npm/#代码实现-3" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/npm/#结语-3" class="sidebar-link">结语</a></li></ul></li><li class="sidebar-sub-header"><a href="/npm/#error-report" class="sidebar-link">error-report</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/npm/#开始-4" class="sidebar-link">开始</a></li><li class="sidebar-sub-header"><a href="/npm/#版本迭代-4" class="sidebar-link">版本迭代</a></li><li class="sidebar-sub-header"><a href="/npm/#需求场景-4" class="sidebar-link">需求场景</a></li><li class="sidebar-sub-header"><a href="/npm/#初步设想-4" class="sidebar-link">初步设想</a></li><li class="sidebar-sub-header"><a href="/npm/#代码实现-4" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/npm/#结语-4" class="sidebar-link">结语</a></li></ul></li></ul></li><li><a href="/h5/" class="sidebar-link">H5</a></li><li><a href="/mp/" class="sidebar-link">小程序</a></li><li><a href="/kyy/" class="sidebar-link">快应用</a></li><li><a href="/other/" class="sidebar-link">其他</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>npm包均为公司内部npm仓库所有</p> <p>npm仓库源: http://xxx</p></div> <div class="custom-block danger"><p class="custom-block-title">重要提示</p> <p>如果依赖有更新，请在依赖所在的 README.md 文件下进行更新的描述。</p></div> <h2 id="stat"><a href="#stat" class="header-anchor">#</a> stat</h2> <blockquote><p>具体用法参考项目地址：client-stat</p></blockquote> <h3 id="开始"><a href="#开始" class="header-anchor">#</a> 开始</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Stat <span class="token keyword">from</span> <span class="token string">'stat'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token comment">/* VuePlugin, WatchRoutePlugin, NativePlugin, NativePlugin_3, */</span> H5_format <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'stat/plugins'</span>
<span class="token comment">// import hostSdk from 'host-sdk'</span>
<span class="token comment">// import WatchRoute from 'watch-route'</span>

<span class="token keyword">const</span> stat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stat</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">report</span><span class="token punctuation">(</span><span class="token parameter">datas</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'埋点上报: '</span><span class="token punctuation">,</span> datas<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
	plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token comment">// new VuePlugin(),</span>
        <span class="token comment">// new WatchRoutePlugin(WatchRoute),</span>
		<span class="token comment">// new NativePlugin(hostSdk),</span>
		<span class="token comment">// new NativePlugin_3(hostSdk), // 要求 host-sdk 3.x 版本及以上</span>
        <span class="token keyword">new</span> <span class="token class-name">H5_format</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="版本迭代"><a href="#版本迭代" class="header-anchor">#</a> 版本迭代</h3> <ul><li>在 1.x - 2.x 版本中，强耦合于vue项目，功能移植困难</li> <li>在 3.x 版本中，已完成轻耦合，但使用方式欠妥，且参数配置过多</li> <li>在 4.x 版本中，已完成完全解耦，以插件的形式注入需要的模块</li></ul> <h3 id="需求场景"><a href="#需求场景" class="header-anchor">#</a> 需求场景</h3> <ul><li>在纯H5中使用</li> <li>在交互式webview中使用</li> <li>与vue集成</li></ul> <h3 id="初步设想"><a href="#初步设想" class="header-anchor">#</a> 初步设想</h3> <ul><li>需要适用于多场景</li> <li>需要可读性</li> <li>需要可扩展</li> <li>实现解耦</li></ul> <p>...</p> <p>综上，初步以 webpack 的 插件(plugins) 形式进行编写并使用。
插件的形式能够足够好的支持</p> <ul><li>多场景(即一个插件针对一个场景)</li> <li>高扩展(可自编写适用当前场景插件)</li> <li>增强可读性(即一个插件代表一个功能模块，通过组合使用插件可以达到需要的效果)</li> <li>与项目解耦(使用对应插件引入对应依赖)</li></ul> <h3 id="代码实现"><a href="#代码实现" class="header-anchor">#</a> 代码实现</h3> <ul><li>项目使用 Symbol 作为私有变量名(其实没必要)</li> <li>使用 get</li> <li>使用 static</li> <li>围绕当前路由 pathname 作为 key 存储上报过的记录，来做上报限制</li></ul> <p>首先初始化的时候需要将插件导入到插件列表，
然后完成自身的初始化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 初始化插件，将当前stat实例传入插件使用</span>
plugins<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">plugin</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFn</span><span class="token punctuation">(</span>plugin<span class="token punctuation">.</span>apply<span class="token punctuation">)</span><span class="token punctuation">)</span> plugin<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>plugin<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFn</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">plugin</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 然后初始化自身所需操作</span>
<span class="token keyword">this</span><span class="token punctuation">[</span>init<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>然后确认到，埋点共有三种类型，一种是页面类型的埋点，一种是节点展示类型的埋点，还有就是点击类型，
于是可以声明三个方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 页面或者主动埋点</span>
<span class="token function">pageReport</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 节点展示的被动埋点</span>
<span class="token function">nodeReport</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 点击埋点</span>
<span class="token comment">// 点击类型其实可以更改action参数来使用pageReport，但是为了更加直观，于是单独列出</span>
<span class="token function">clickReport</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</code></pre></div><p>这时候，由于节点的展示埋点属于被动埋点，所以需要在节点渲染之后把节点dom以及节点的埋点参数添加到一个节点数组中，
然后在滚动的时候判断节点的位置，如果在窗口中则进行上报(这里添加的当前页面key的所有节点都会查询一次，查询位置会引起重排，如果节点过多可能会有性能问题，可参考无限滚动处理)，
那么在这时候，就需要好几个方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 添加节点</span>
<span class="token comment">// 这里的id是让stat知道节点是新增还是更新，并且方便移除</span>
<span class="token function">addNode</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> <span class="token operator">...</span>params <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 移除节点</span>
<span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 添加节点进入数组</span>
<span class="token function">setNodeList</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span> <span class="token punctuation">{</span> el<span class="token punctuation">,</span> <span class="token operator">...</span>params <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 获取当前页面key的节点数组</span>
<span class="token function">getNodeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 添加节点事件列表</span>
<span class="token comment">// 使用事件时可以无需再次手动的调用 clickReport</span>
<span class="token comment">// 由节点 click 事件代替完成</span>
<span class="token function">setEventList</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span> event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 获取当前页面key的节点事件列表</span>
<span class="token function">getEventList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</code></pre></div><p>这时候上报的途径已经有了，那么就需要上报的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 上报需要一个原始的数据</span>
<span class="token function">getBaseData</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 初始数据基本是无法用作上报的，所以这时候需要一个数据格式化的操作</span>
<span class="token comment">// 这里由插件来制定上报所需的数据格式(例如 H5_format, native 插件)</span>
<span class="token comment">// 内部会走一个数组的依次执行并传递执行结果的逻辑，类似管道符的操作，故这里可能会存在执行顺序问题</span>
<span class="token function">formatData</span><span class="token punctuation">(</span><span class="token parameter">datas</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token comment">// 在拿到格式化后的数据，就可以进行上报了</span>
<span class="token comment">// 在这个入口中，可以处理缓存，处理数据，当作一个控制器来使用</span>
<span class="token function">report</span><span class="token punctuation">(</span><span class="token parameter">datas</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</code></pre></div><p>其实到这个时候，从数据采集到上报基本就完成了，剩下的只是一些细节上的补充和各个环境插件的编写</p> <ul><li>VuePlugin 插件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 该插件仅提供 v-stat 指令，无其他依赖或操作</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'stat'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    inserted<span class="token operator">:</span> addNode<span class="token punctuation">,</span>
    componentUpdated<span class="token operator">:</span> addNode<span class="token punctuation">,</span>
    unbind<span class="token operator">:</span> removeNode<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>WatchRoutePlugin 插件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 该插件提供 parent, pageFrom 类型参数</span>
<span class="token comment">// 对格式化顺序有要求(更改的是源数据)，需要放在前面</span>
<span class="token comment">// 这里的 listen 是 stat 实例的方法，用作监听路由改变</span>
stat<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        parentPage<span class="token operator">:</span> <span class="token function">getPageName</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>href <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        parentParams<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span>parent<span class="token punctuation">.</span>query <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
        
stat<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token parameter">datas</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>

    datas<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>data<span class="token punctuation">.</span>pageFrom <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>pageFrom <span class="token operator">=</span> pageFrom<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> datas
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>NativePlugin NativePlugin_3 插件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这个插件处理的东西较多：设置上报方法、更改数据格式、页面end埋点、跳转客户端埋点</span>
<span class="token comment">// 这里就不展示太多了，具体见 stat 源码</span>
stat<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span>
</code></pre></div><ul><li>H5_format 插件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这里就仅仅是格式化h5下面的埋点的数据格式</span>
stat<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token parameter">datas</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">,</span> datas<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>这里讲一下节点展示逻辑</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>ids<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">id</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 已上传过</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>history<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">delete</span> nodes<span class="token punctuation">[</span>id<span class="token punctuation">]</span>

    <span class="token keyword">const</span> <span class="token punctuation">{</span> el<span class="token punctuation">,</span> unView<span class="token punctuation">,</span> params <span class="token punctuation">}</span> <span class="token operator">=</span> nodes<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>unView<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>el<span class="token punctuation">.</span>getBoundingClientRect<span class="token punctuation">)</span> <span class="token keyword">return</span>

    <span class="token comment">// 这里主要通过 getBoundingClientRect 方法获取到节点所在窗口的位置 </span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> left<span class="token punctuation">,</span> top <span class="token punctuation">}</span> <span class="token operator">=</span> el<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 然后获取到节点的宽高</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> offsetWidth<span class="token punctuation">,</span> offsetHeight <span class="token punctuation">}</span> <span class="token operator">=</span> el

    <span class="token comment">// 再以节点的高度或宽度的 1/3 在窗口内时，即计入上报标准进行上报</span>
    <span class="token comment">// 并将上上报过的节点id进行缓存，防止当前页面的二次上报(无效数据)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
        <span class="token comment">// 在窗口内</span>
        left <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">-</span> offsetWidth <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span>
        left <span class="token operator">&lt;=</span> innerWidth <span class="token operator">-</span> offsetWidth <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span>
        top <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">-</span> offsetHeight <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span>
        top <span class="token operator">&lt;=</span> innerHeight <span class="token operator">-</span> offsetHeight <span class="token operator">/</span> <span class="token number">3</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        reportList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span>
        <span class="token keyword">delete</span> nodes<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
        history<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="结语"><a href="#结语" class="header-anchor">#</a> 结语</h3> <p>在一个插件的初期编写是比较困难的，当时并没有多端的需求，导致了与vue项目的重度耦合，在第二个项目需要时移植特别困难，
很多逻辑都依赖于vue及vue-router，但是重度依赖的原因是想通过一套逻辑来解决复制粘贴(每个页面都有view，且parent的处理比较麻烦)。
这里由自己实现的watch-route来代替vue-router，这时候其实对vue的耦合已经不多了，再通过插件的形式引入时，就已经完成对vue的解耦了，现在可以在各个h5项目上面使用。
一个平台对应一个插件，插件编写也简单，不需要耗费太多时间，倘若又新增了一个平台，现在也只需要新增一个对应的插件，甚至不需要新增(快应用)。</p> <h2 id="watch-route"><a href="#watch-route" class="header-anchor">#</a> watch-route</h2> <blockquote><p>具体用法参考项目地址：watch-route</p></blockquote> <h3 id="开始-2"><a href="#开始-2" class="header-anchor">#</a> 开始</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> WatchRoute <span class="token keyword">from</span> <span class="token string">'watch-route'</span>

<span class="token keyword">const</span> watchRoute <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WatchRoute</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
</code></pre></div><h3 id="版本迭代-2"><a href="#版本迭代-2" class="header-anchor">#</a> 版本迭代</h3> <ul><li>1.x 基本定型</li> <li>2.x 添加对stat插件的兼容且为了避免线上包的自动更新</li></ul> <h3 id="需求场景-2"><a href="#需求场景-2" class="header-anchor">#</a> 需求场景</h3> <ul><li>为了与 vue-router 解耦的产物</li></ul> <h3 id="初步设想-2"><a href="#初步设想-2" class="header-anchor">#</a> 初步设想</h3> <p>该依赖是为了vue-router解耦而存在，可用在所有h5项目，
那么该监听就应该是纯被动监听，不应有主动交互，在这个依赖中其他角色仅能进行获取数据操作。</p> <h3 id="代码实现-2"><a href="#代码实现-2" class="header-anchor">#</a> 代码实现</h3> <p>既然是作为一个只读的路由依赖，那么该依赖就需要提供足够完整的数据，
那么这里有几个基础的功能</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 页面栈，这里的 getStack 是取 session 内存储的 stack，防止刷新页面时页面栈丢失</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>_pageStack <span class="token operator">=</span> <span class="token function">getStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 页面链(用户行为路线)， getChain 同上</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>_chain <span class="token operator">=</span> <span class="token function">getChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 简化获取当前页面信息</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>currentPage
<span class="token comment">// 简化获取parent页面</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>parentPage
<span class="token comment">// 用于跳转时的钩子</span>
<span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</code></pre></div><p>基础功能有了，那么就剩下如何监听了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 由于 window.location 不可代理，就没有进行代理</span>
<span class="token comment">// 故在使用 location 进行跳转或返回时，可能会产生误差</span>

<span class="token comment">// 好在 history 可以进行代理</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> back<span class="token punctuation">,</span> forward<span class="token punctuation">,</span> go<span class="token punctuation">,</span> pushState<span class="token punctuation">,</span> replaceState <span class="token punctuation">}</span> <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token class-name">History</span><span class="token punctuation">.</span>prototype
<span class="token comment">// 这里的 -1 1 0 是指对页面栈层级的影响，1 即为推入一层页面栈，0 为刷新顶层页面栈， -1 为删除顶层页面栈</span>
<span class="token keyword">const</span> kv <span class="token operator">=</span> <span class="token punctuation">{</span>
    back<span class="token operator">:</span> <span class="token punctuation">[</span>back<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    forward<span class="token operator">:</span> <span class="token punctuation">[</span>forward<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    pushState<span class="token operator">:</span> <span class="token punctuation">[</span>pushState<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    replaceState<span class="token operator">:</span> <span class="token punctuation">[</span>replaceState<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    go<span class="token operator">:</span> <span class="token punctuation">[</span>go<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>kv<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token class-name">History</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">...</span>
</code></pre></div><p>在主动行为的代理完成后，需要监听浏览器的行为(前进、返回)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这里监听浏览器跳转有两个方式</span>
<span class="token comment">// 一个是监听 popstate</span>
<span class="token comment">// 一个是监听 hashchange</span>
<span class="token comment">// 但是在这里发现 popstate 也能监听到 hashchange 能监听的事件(hash改变)</span>
<span class="token comment">// 显然 popstate 更加完善，便使用 popstate 作为主要监听对象</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
</code></pre></div><p>具体细节代码较多，可以直接看源码。这里主要是通过代理及监听来完成自主的页面栈功能(即页面栈、页面链都在这里面进行进栈出栈操作)，
除了一直用 location 进行跳转且 前进后退前进后退，不然是可以保证页面栈的正确性的。
且这类跳转为极少数，故该依赖是可用的。</p> <h3 id="结语-2"><a href="#结语-2" class="header-anchor">#</a> 结语</h3> <p>该依赖有种为了写而写的意思，但是写出来确实也能实现与vue的解耦，可以使用在所有H5中，不存在第三方依赖，
自身就是第三方依赖的依赖，为了更好的完成埋点需求而存在。</p> <p>该依赖没有用什么好的方式，就是最纯粹的代理拦截，只是内部需要处理的细节比较多，比如在主动跳转的时候，监听的popstate也会触发，
这时候就需要做一个阻断。还要处理刷新页面的时候，这时候相当于是刷新顶层栈，而非推入栈，等等其他细节。</p> <h2 id="host-sdk"><a href="#host-sdk" class="header-anchor">#</a> host-sdk</h2> <blockquote><p>具体用法参考项目地址：host-sdk</p></blockquote> <h3 id="开始-3"><a href="#开始-3" class="header-anchor">#</a> 开始</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Sdk <span class="token keyword">from</span> <span class="token string">'host-sdk'</span>

Sdk<span class="token punctuation">.</span><span class="token function">partyCall</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 调用 成功 回调</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 调用 失败/取消 的回调</span>
</code></pre></div><h3 id="版本迭代-3"><a href="#版本迭代-3" class="header-anchor">#</a> 版本迭代</h3> <ul><li>1.x - 2.x 版本中，用法无区别，仅新增新的交互方法</li> <li>3.x 使用 typescript 进行重构，改善易用性</li></ul> <h3 id="需求场景-3"><a href="#需求场景-3" class="header-anchor">#</a> 需求场景</h3> <p>与客户端交互，由于老版本使用方式太麻烦，故进行了重构</p> <h3 id="初步设想-3"><a href="#初步设想-3" class="header-anchor">#</a> 初步设想</h3> <ul><li>增强易用性</li> <li>改善可读性</li></ul> <p>由于历史原因，客户端在调用sdk回调的时候，并没有告诉h5是哪个方法(key)的回调，
并且有的方法没有回调，最开始想的是，既然客户端没有返回 key 值，那就从返回的值里面，
通过值的组成格式，来判断是哪一个方法的回调，这种方式实现起来需要去调客户端的所有方法来确认返回值格式，
需要确认哪些方法是否有返回值，得花点时间。但是在客户端无法更改的情况下，只能这么去做了。</p> <h3 id="代码实现-3"><a href="#代码实现-3" class="header-anchor">#</a> 代码实现</h3> <p>首先需要判断所在平台，进行平台的初始化(初始化交互逻辑)，
初始化完成后，将各个平台的回调统一到 window.host_sdk 下的回调执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 平台初始化</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>isApple<span class="token punctuation">)</span> <span class="token function">iosInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isKyy<span class="token punctuation">)</span> <span class="token function">kyyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">else</span> <span class="token function">androidInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>于是这里就有了一个客户端触发回调的入口</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 操作成功后的回调</span>
<span class="token function-variable function">successCallback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">SDK</span><span class="token punctuation">.</span><span class="token function">runSuccessCallback</span><span class="token punctuation">(</span><span class="token operator">...</span>res<span class="token punctuation">)</span>
</code></pre></div><p>入口有了之后，就可以从开始的想法入手，
以前为了回调的准确性，在某些时候只能一个一个进行调用，否则之前回调未完成时，会被后面的回调覆盖，
那么这时候就可以把调用的回调推入一个回调队列，等待回调的执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">SDK</span><span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>call<span class="token operator">:</span> Methodable<span class="token punctuation">)</span>
</code></pre></div><p>现在已经有了回调队列及客户端回调入口，在只有单个回调的时候，已经能够完成客户端对H5的回调交互。
在同时有多个回调的时候，就可以使用返回值匹配来进行辨识回调(一种值对应一个方法，一个方法对应一个回调)。
在匹配完成后，就可以拿到返回值对应的方法的回调了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这里提供一个方法声明的demo</span>
<span class="token comment">// 获取客户端详情</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> getInfo<span class="token operator">:</span> Methodable <span class="token operator">=</span> <span class="token punctuation">{</span>
    successMatch<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'version'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    handle<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter"><span class="token keyword">void</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>isApple<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            window<span class="token punctuation">.</span>ios_hostsdk<span class="token punctuation">.</span><span class="token function">callHandler</span><span class="token punctuation">(</span><span class="token string">'getInfo'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            window<span class="token punctuation">.</span><span class="token function">androidCallHandler</span><span class="token punctuation">(</span><span class="token string">'getInfo'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里是匹配值的方式</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当值为字符串的时候，匹配字符串中的值是否包含设定的值，如果有，则证明该值是对应方法的回调</span>
    <span class="token keyword">case</span> <span class="token string">'string'</span><span class="token operator">:</span> <span class="token keyword">return</span> callbacks<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">call</span> <span class="token operator">=&gt;</span> call<span class="token punctuation">.</span>match<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> res<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// 当值为对象的时候，匹配对象下面的键值(key)，如果都匹配成功，则证明该值是对应方法的回调</span>
    <span class="token keyword">case</span> <span class="token string">'object'</span><span class="token operator">:</span> <span class="token keyword">return</span> callbacks<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">call</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token operator">!</span>call<span class="token punctuation">.</span>match<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> call<span class="token punctuation">.</span>match<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 其他类型则匹配没有 match 匹配列表的方法对应的回调</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">return</span> callbacks<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">call</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>call<span class="token punctuation">.</span>match<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="结语-3"><a href="#结语-3" class="header-anchor">#</a> 结语</h3> <p>在这个依赖中，比较重要的是解决多方法同时调用并且能够准确的拿到对应回调，
以及对应方法必须正确的填写匹配(match)所需要的字段，达到正确匹配的效果。
当时在编写快应用环境的时候，其实可以与客户端区分开来，
但是当时没有考虑到(当时想的是跟客户端保持一致，快应用的H5可能会给客户端使用，结果到现在就没有与客户端共用过)，
导致现在快应用在使用H5页面时，回调还是会有问题(请求需要附带公参，公参需要进行交互获取)，
说明该依赖的匹配规则还有待优化。</p> <h2 id="error-report"><a href="#error-report" class="header-anchor">#</a> error-report</h2> <blockquote><p>具体用法参考项目地址：error-report</p></blockquote> <h3 id="开始-4"><a href="#开始-4" class="header-anchor">#</a> 开始</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;https://c.sxyj.net/webresource/plugins/error-report.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token keyword">var</span> errorReport <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ErrorReport</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'&lt;项目名称&gt;'</span><span class="token punctuation">,</span>
    url<span class="token operator">:</span> <span class="token string">'http://xxx'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 如果在vue环境中使用，由于vue内部有错误捕获机制，需要手动绑定一次</span>
<span class="token comment">// Vue.config.errorHandler = (...err) =&gt; console.error(...err) || errorReport.report(...err, { target: 'vue' })</span>
</code></pre></div><h3 id="版本迭代-4"><a href="#版本迭代-4" class="header-anchor">#</a> 版本迭代</h3> <ul><li>1.x 基础版本</li> <li>2.x 使用 class 进行重构，新增黑名单，核心逻辑并无大改</li></ul> <h3 id="需求场景-4"><a href="#需求场景-4" class="header-anchor">#</a> 需求场景</h3> <p>在测试环境中，报错都能够及时的看到并解决，但是在生产环境中，
报错信息往往不能及时的捕获并处理，所以需要一个错误监控，来解决生产环境的报错。</p> <h3 id="初步设想-4"><a href="#初步设想-4" class="header-anchor">#</a> 初步设想</h3> <p>能够准确的监听到各类错误并及时的上报</p> <h3 id="代码实现-4"><a href="#代码实现-4" class="header-anchor">#</a> 代码实现</h3> <p>在写代码之前，需要确认都有哪些类型错误：</p> <ul><li>节点错误(渲染错误？src错误？)</li> <li>事件错误(其实就是函数执行错误，逻辑错误)</li> <li>http请求错误</li></ul> <p>确认了这三大类型(或许有更多？)错误之后，就可以先创建三个js文件(单一职责) domError eventError httpError，
在 domError 和 eventError 中，都只需要添加监听即可</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// domError</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>closeDOM <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'dom'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    capture<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    once<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    passive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// eventError</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>closeEvent <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token punctuation">{</span> target<span class="token operator">:</span> <span class="token string">'event'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    capture<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    once<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    passive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>但是在http请求中，为了自主的捕获到错误，在这里使用代理的方式比较方便</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> _XMLHttpRequest <span class="token operator">=</span> window<span class="token punctuation">.</span>XMLHttpRequest

window<span class="token punctuation">.</span><span class="token function-variable function">XMLHttpRequest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
</code></pre></div><p>那么到这里，错误的捕获就已经完成了，但是错误的元信息肯定是有所欠缺的，
需要准确的知道当前错误所在的页面信息，于是该依赖引入了 watch-route 模块，从中获取所需的页面信息。
这里再把数据格式处理一下然后上传一下就行了(这里用的阿里云监控自定义事件)</p> <p>但是针对于vue，vue因为有自己的捕获，而且我们需要详细的知道是在哪一个模块出现的问题，
这里需要针对于vue进行一次插件封装。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这个方法忘了在哪里找的了，好像是fundebug？</span>
<span class="token comment">// 用于获取组件的名称</span>
<span class="token keyword">const</span> <span class="token function-variable function">formatComponentName</span> <span class="token operator">=</span> <span class="token parameter">vm</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$root <span class="token operator">===</span> vm<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'root'</span>

    <span class="token keyword">const</span> name <span class="token operator">=</span> vm<span class="token punctuation">.</span>_isVue
        <span class="token operator">?</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">||</span>
          <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_componentTag<span class="token punctuation">)</span>
        <span class="token operator">:</span> vm<span class="token punctuation">.</span>name
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token punctuation">(</span>name <span class="token operator">?</span> <span class="token string">'component &lt;'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'&gt;'</span> <span class="token operator">:</span> <span class="token string">'anonymous component'</span><span class="token punctuation">)</span> <span class="token operator">+</span>
        <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isVue <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>__file
            <span class="token operator">?</span> <span class="token string">' at '</span> <span class="token operator">+</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>__file<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里获取到组件名称之后其实已经足够了，只是对于其他框架的错误捕获还未支持(如果其他框架也有自身的错误捕获的话)，
在后期需要的时候可以更新一下 target ，然后使用添加对应的方法，基本就没什么问题。</p> <p>在2.x版本中引入了黑名单模式，因为客户端环境或其他环境中，有些自身的错误，这时候也会被捕获，
但其实是没有必要的，所以用黑名单过滤一下，减少垃圾信息。</p> <h3 id="结语-4"><a href="#结语-4" class="header-anchor">#</a> 结语</h3> <p>该依赖最初是参考 fundebug 做的，当时 fundebug 也不怎么健全，
上报信息里面有 message 及 错误栈，还有一些当前页面的路由信息。
在写这个的时候也就多了一个用户行为路线(watch-route 提供)信息，如果还要更加具体的话，
可以想想怎么样能和 source map 结合起来，给出更加准确的报错位置(在哪一行，哪一列，哪一句)，
使之更加容易定位及处理问题。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">4/3/2020, 8:11:34 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/" class="prev">
        指南
      </a></span> <span class="next"><a href="/h5/">
        H5
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.cf21e5a9.js" defer></script><script src="/assets/js/2.1fbd1c76.js" defer></script><script src="/assets/js/10.06005cdb.js" defer></script>
  </body>
</html>
